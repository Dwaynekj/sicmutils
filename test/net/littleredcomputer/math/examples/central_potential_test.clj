(ns net.littleredcomputer.math.examples.central-potential-test
  (:refer-clojure :exclude [+ - * /])
  (:require [net.littleredcomputer.math.env :refer :all]
            [net.littleredcomputer.math.mechanics.lagrange :refer :all]
            [net.littleredcomputer.math.examples.central-potential :as central]
            [clojure.test :refer :all]))

(deftest equations
  (with-literal-functions
    [m M x y X Y]
    (let [state (up 't (up 'x 'y) (up 'xDot 'yDot))
          state2 (up 't (up 'x 'y 'X 'Y) (up 'dx 'dy 'dX 'dY))
          L (central/L-central 'M 'm 0 0)]
      (is (= '(+ (* 1/2 M (expt xDot 2))
                 (* 1/2 M (expt yDot 2))
                 (* -1 (/ (* -1 M m) (sqrt (+ (expt x 2) (expt y 2))))))
             (simplify (L state))))
      (is (= '(+ (* 1/2 m1 (expt x1' 2))
                 (* 1/2 m1 (expt y1' 2))
                 (* 1/2 m2 (expt x2' 2))
                 (* 1/2 m2 (expt y2' 2)))
             (simplify ((central/T 'm1 'm2) (up 0 (up 'x1 'y1 'x2 'y2) (up 'x1' 'y1' 'x2' 'y2'))))))
      (is (= '(* -1 (/ (* m1 m2)
                       (sqrt (+ (expt x1 2) (expt y1 2)))))
             (simplify ((central/V 'm1 'm2) (up 0 (up 'x1 'y1 0 0) (up 'x1' 'y1' 'x2' 'y2'))))))
      (is (= '(+ (* 1/2 m1 (expt x1' 2))
                 (* 1/2 m1 (expt y1' 2))
                 (* 1/2 m2 (expt x2' 2))
                 (* 1/2 m2 (expt y2' 2))
                 (/ (* m1 m2)
                    (sqrt (+ (expt x1 2) (expt y1 2)))))
             (simplify ((central/L 'm1 'm2) (up 0 (up 'x1 'y1 0 0) (up 'x1' 'y1' 'x2' 'y2'))))))
      ;; haven't checked these; we're still debugging this
      (let [state (up 0 (up 'x1 'y1 0 0) (up 'x1' 'y1' 'x2' 'y2'))
            F ((∂ 1) (central/L 'm1 'm2))
            P ((∂ 2) (central/L 'm1 'm2))
            A ((∂ 2) P)]
        (is (= '(down (* -2 (/ 1 (* 2 (sqrt (+ (expt x1 2) (expt y1 2))))) (/ (* m1 m2) (+ (expt x1 2) (expt y1 2))) x1)
                      (* -2 (/ 1 (* 2 (sqrt (+ (expt x1 2) (expt y1 2))))) (/ (* m1 m2) (+ (expt x1 2) (expt y1 2))) y1)
                      (* 2 (/ 1 (* 2 (sqrt (+ (expt x1 2) (expt y1 2))))) (/ (* m1 m2) (+ (expt x1 2) (expt y1 2))) x1)
                      (* 2 (/ 1 (* 2 (sqrt (+ (expt x1 2) (expt y1 2))))) (/ (* m1 m2) (+ (expt x1 2) (expt y1 2))) y1))
               (simplify (F state))))
        (is (= '(down (* m1 x1')
                      (* m1 y1')
                      (* m2 x2')
                      (* m2 y2'))
               (simplify (P state))))
        (is (= '(down (down m1 0 0 0)
                      (down 0 m1 0 0)
                      (down 0 0 m2 0)
                      (down 0 0 0 m2))
               (simplify (A state)))))
      (is (= '(down (+ (* 2 (x t) (/ 1 (* 2 (sqrt (+ (expt (x t) 2) (expt (y t) 2))))) (/ (* M m) (+ (expt (x t) 2) (expt (y t) 2)))) (* (((expt D 2) x) t) m))
                    (+ (* 2 (y t) (/ 1 (* 2 (sqrt (+ (expt (y t) 2) (expt (x t) 2))))) (/ (* M m) (+ (expt (y t) 2) (expt (x t) 2)))) (* (((expt D 2) y) t) m))
                    (* -2 (x t) (/ 1 (* 2 (sqrt (+ (expt (x t) 2) (expt (y t) 2))))) (/ (* M m) (+ (expt (x t) 2) (expt (y t) 2))))
                    (* -2 (y t) (/ 1 (* 2 (sqrt (+ (expt (y t) 2) (expt (x t) 2))))) (/ (* M m) (+ (expt (y t) 2) (expt (x t) 2)))))
             (simplify (((Lagrange-equations (central/L 'm 'M))
                         (up x y (constantly 0) (constantly 0))) 't))))
      (is (= '(up 1
                  (up dx dy dX dY)
                  (up (+ (* 2 (/ 1 (* 2 (sqrt (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))))) (/ (* M m) (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))) (/ (* (expt M 2) m) (* (expt M 2) (expt m 2))) X)
                         (* -2 (/ 1 (* 2 (sqrt (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))))) (/ (* M m) (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))) (/ (* (expt M 2) m) (* (expt M 2) (expt m 2))) x))
                      (+ (* 2 (/ 1 (* 2 (sqrt (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))))) (/ (* M m) (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))) (/ (* (expt M 2) m) (* (expt M 2) (expt m 2))) Y)
                         (* -2 (/ 1 (* 2 (sqrt (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))))) (/ (* M m) (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))) (/ (* (expt M 2) m) (* (expt M 2) (expt m 2))) y))
                      (+ (* -2 (/ 1 (* 2 (sqrt (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))))) (/ (* M m) (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))) (/ (* M (expt m 2)) (* (expt M 2) (expt m 2))) X)
                         (* 2 (/ 1 (* 2 (sqrt (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))))) (/ (* M m) (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))) (/ (* M (expt m 2)) (* (expt M 2) (expt m 2))) x))
                      (+ (* -2 (/ 1 (* 2 (sqrt (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))))) (/ (* M m) (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))) (/ (* M (expt m 2)) (* (expt M 2) (expt m 2))) Y)
                         (* 2 (/ 1 (* 2 (sqrt (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))))) (/ (* M m) (+ (expt X 2) (* -2 X x) (expt Y 2) (* -2 Y y) (expt x 2) (expt y 2))) (/ (* M (expt m 2)) (* (expt M 2) (expt m 2))) y))))
             (simplify ((central/state-derivative 'm 'M) state2))))
      (is (= '(down
               (+ (* -2 (x t)
                     (/ 1 (* 2 (sqrt (+ (expt (x t) 2) (expt (y t) 2)))))
                     (/ (* -1 M m) (+ (expt (x t) 2) (expt (y t) 2))))
                  (* (((expt D 2) x) t) M))
               (+ (* -2 (y t)
                     (/ 1 (* 2 (sqrt (+ (expt (y t) 2) (expt (x t) 2)))))
                     (/ (* -1 M m) (+ (expt (y t) 2) (expt (x t) 2))))
                  (* (((expt D 2) y) t) M)))
             (simplify (((Lagrange-equations L) (up x y)) 't))))
      (is (central/evolver 1 1/60 1 20 20 -2 0)))))
